---
aliases:
  - "Docker: Инициализация postgres"
tags:
  - self-hosted
  - docker
  - database
  - postgresql
title: "Docker: Инициализация postgres"
date: 2012-09-06
created: 2015-09-06T00:39:07+03:00
modified: 2025-04-30T22:07:19+03:00
permalink: linux/2015-09-06-docker-initsializatsiia-postgres
---

Где-то полгода назад по личной инициативе я стал разворачивать компоненты в **docker** контейнерах для разработки и тестирования продуктов. При этом самая сложная система состояла из базы данных (_postgres_) и пары _tomcat_'ов. Самое оно чтобы попробовать новую технологию. Такой подход позволял в чем-то эмулировать production окружение и не засорять рабочую машину.

> [!info]
> Заметка из 2015-го года! Ранее была [опубликована в старом блоге](https://old.puzan.dev/linux/2015-09-06-docker-initsializatsiia-postgres.html).

В то время я столкнулся с несколько проблематичным способом инициализации бд из официального _postgres_ образа во время старта контейнера. Тогда все сводилось к тому чтобы написать скрипт, который стартует _postgres_ в _single_ режиме и выполняет нужные _sql_ запросы. Например вот так:

```bash
#!/bin/bash

gosu postgres postgres --single < ${INIT_SQL}/create-testdb.sql
gosu postgres postgres --single -j testdb < ${INIT_SQL}/date-db.sql
```

Затем скрипт и _sql_ файлы надо было добавить в контейнер во время _build_ в папочку `/docker-entrypoint-initdb.d/`. Пример _Dockerfile_:

```Dockerfile
FROM postgres:9

ENV INIT_SQL /init-sql

COPY init-db.sh /docker-entrypoint-initdb.d/
COPY *.sql ${INIT_SQL}/
```

А далее на старте контейнера запускался _docker-entrypoint.sh_, который выполнял все скрипты из `/docker-entrypoint-initdb.d/`.

Это работало, но было очень не удобно. Главная проблема - необходимость запускать _postgres_ в _single_ режиме, так как на момент выполнения postgres еще не был стартован. Из-за этого возникают ограничения в _SQL_ запросах, а также невозможно подложить dump сделанный `pg_dump`'ом либо подключиться с помощью `psql`.

Пока я собирался с мыслями чтобы опубликовать вышеописанный метод, _docker-entrypoint.sh_ был [переписан][docker-update]. Теперь на время инициализации базы запускается полноценный экземпляр базы, с которым можно взаимодействовать с помощью `psql`. Также появилась возможность создавать базу и пользователя через определение переменных окружения. Плюс _shell_ скрипт теперь писать не обязательно. Просто складываем _sql_ файлы в `/docker-entrypoint-initdb.d/`, а они передаются на выполнение в `psql`. Красотень.

В конце хотел бы отметить, что нынче технологии развиваются и меняются очень быстро. Надо быть все время на чеку. По идее вышеописанные изменения в _docker-entrypoint.sh_ для _postgres_ образа могут привести к вероятным проблемам (особенно если ранее _sql_ скрипты складывали в `/docker-entrypoint-initdb.d/` папку), а вот версионирования образов в зависимости от изменения _Dockerfile_ на [хабе][hub] нету. Отсюда вывод - без своего _docker registry_ никак не обойтись и на внешние образы лучше не надеяться.

[docker-update]: https://github.com/docker-library/postgres/commit/66c7b2dee78980482b83337d16febc4251cb2ae7
[hub]: https://hub.docker.com/
